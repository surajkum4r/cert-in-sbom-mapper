// Vulnerability service using OSV API

class VulnerabilityService {
  constructor() {
    this.cache = new Map();
  }

  normalizeForOsv(packageInfo) {
    // Map internal ecosystems to OSV expected values and names
    const eco = (packageInfo.ecosystem || "").toLowerCase();
    if (eco === "maven" && packageInfo.group && packageInfo.name) {
      // OSV expects Maven name as group:artifact and ecosystem "Maven"
      return { ecosystem: "Maven", name: `${packageInfo.group}:${packageInfo.name}` };
    }
    if (eco === "npm") {
      return { ecosystem: "npm", name: packageInfo.name };
    }
    if (eco === "pypi") {
      return { ecosystem: "PyPI", name: packageInfo.name };
    }
    // Fallback
    return { ecosystem: packageInfo.ecosystem, name: packageInfo.name };
  }

  async fetchVulnerabilityData(packageInfo) {
    if (!packageInfo || packageInfo.ecosystem === "unknown") return null;
    const { ecosystem, name } = this.normalizeForOsv(packageInfo);
    const key = `vuln:${ecosystem}:${name}`;
    if (this.cache.has(key)) return this.cache.get(key);
    try {
      if (process.env.REACT_APP_DEBUG_FETCH === "1") {
        // eslint-disable-next-line no-console
        console.log("[OSV] query", { ecosystem, name });
        if (/gson/i.test(name)) {
          // eslint-disable-next-line no-alert
          alert(`[OSV] query ${ecosystem} ${name}`);
        }
      }
      const res = await fetch("https://api.osv.dev/v1/query", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          package: { name, ecosystem },
        }),
      });
      if (!res.ok) throw new Error(String(res.status));
      const data = await res.json();
      if (process.env.REACT_APP_DEBUG_FETCH === "1") {
        const count = (data?.vulns || []).length;
        // eslint-disable-next-line no-console
        console.log("[OSV] response", { status: res.status, vulns: count });
        if (/gson/i.test(name)) {
          // eslint-disable-next-line no-alert
          alert(`[OSV] response vulns=${count}`);
        }
      }
      let result = { hasVulnerabilities: false, patchStatus: "Up to date", fixedVersions: [], maxCvssScore: 0 };
      const vulns = data?.vulns || [];
      if (vulns.length > 0) {
        let maxCvss = 0;
        const criticalCount = vulns.filter((v) => {
          const sevArr = Array.isArray(v.severity) ? v.severity : [];
          for (const s of sevArr) {
            const num = typeof s.score === "number" ? s.score : Number(s.score);
            if (!isNaN(num)) {
              if (num > maxCvss) maxCvss = num;
              if (num >= 9) return true;
            } else if (typeof s.score === "string" && s.score.toUpperCase() === "CRITICAL") {
              return true;
            }
          }
          return false;
        }).length;
        const fixed = [];
        for (const v of vulns) {
          const ranges = (v.affected || []).flatMap((a) => a.ranges || []);
          for (const r of ranges) {
            if (Array.isArray(r.events)) {
              r.events.forEach((ev) => {
                if (ev.introduced === "0") return; // ignore baseline
                if (ev.fixed) fixed.push(ev.fixed);
              });
            }
          }
        }
        result = {
          hasVulnerabilities: true,
          criticalVulns: criticalCount,
          totalVulns: vulns.length,
          patchStatus: "Update available",
          fixedVersions: Array.from(new Set(fixed)).filter(Boolean),
          maxCvssScore: maxCvss,
        };
      }
      this.cache.set(key, result);
      return result;
    } catch (err) {
      if (process.env.REACT_APP_DEBUG_FETCH === "1") {
        // eslint-disable-next-line no-console
        console.log("[OSV] error", err);
      }
      // Ensure we still cache a null result briefly to avoid hammering
      this.cache.set(key, null);
      return null;
    }
  }

  determineCriticality(vulnData) {
    if (vulnData?.criticalVulns > 0) return "Critical";
    if (vulnData?.totalVulns > 5) return "High";
    if (vulnData?.totalVulns > 0) return "Medium";
    return "Low";
  }
}

export default VulnerabilityService;


